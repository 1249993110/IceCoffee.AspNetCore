<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ValidationContextServiceContainer_ItemAlreadyExists" xml:space="preserve">
    <value>容器中已存在一个“{0}”类型的服务。</value>
  </data>
  <data name="ValidationContext_Must_Be_Method" xml:space="preserve">
    <value>类型为“{0}”的成员名“{1}”的 ValidationContext 必须提供 MethodInfo。</value>
  </data>
  <data name="CompareAttribute_UnknownProperty" xml:space="preserve">
    <value>找不到名为 {0} 的属性。</value>
  </data>
  <data name="CustomValidationAttribute_Type_Conversion_Failed" xml:space="preserve">
    <value>未能按方法 {2}.{3} 预期的方式将“{0}”类型的值转换为“{1}”。</value>
  </data>
  <data name="RangeAttribute_MinGreaterThanMax" xml:space="preserve">
    <value>最大值“{0}”必须大于或等于最小值“{1}”。</value>
  </data>
  <data name="CustomValidationAttribute_Type_Must_Be_Public" xml:space="preserve">
    <value>自定义验证类型“{0}”必须是公共的。</value>
  </data>
  <data name="RangeAttribute_ValidationError" xml:space="preserve">
    <value>字段 {0} 必须在 {1} 和 {2} 之间。</value>
  </data>
  <data name="ArgumentIsNullOrWhitespace" xml:space="preserve">
    <value>参数“{0}”不能为 null、空或仅包含空格。</value>
  </data>
  <data name="RegularExpressionAttribute_Empty_Pattern" xml:space="preserve">
    <value>必须将模式设置为有效的正则表达式。</value>
  </data>
  <data name="CreditCardAttribute_Invalid" xml:space="preserve">
    <value>{0} 字段不是有效的信用卡号码。</value>
  </data>
  <data name="UIHintImplementation_ControlParameterKeyIsNotAString" xml:space="preserve">
    <value>位于位置 {0} 且具有值“{1}”的密钥参数不是字符串。每个密钥控件参数都必须是字符串。</value>
  </data>
  <data name="StringLengthAttribute_ValidationError" xml:space="preserve">
    <value>字段 {0} 必须是最大长度为 {1} 的字符串。</value>
  </data>
  <data name="LocalizableString_LocalizationFailed" xml:space="preserve">
    <value>因本地化失败而无法检索属性“{0}”。类型“{1}”不是公共的，或者不包含名称为“{2}”的公共静态字符串属性。</value>
  </data>
  <data name="StringLengthAttribute_ValidationErrorIncludingMinimum" xml:space="preserve">
    <value>字段 {0} 必须是一个字符串，其最小长度为 {2}，最大长度为 {1}。</value>
  </data>
  <data name="AttributeStore_Unknown_Method" xml:space="preserve">
    <value>类型“{0}”不包含名为“{1}”的公共方法。</value>
  </data>
  <data name="CustomValidationAttribute_Method_Required" xml:space="preserve">
    <value>未指定 CustomValidationAttribute.Method。</value>
  </data>
  <data name="AttributeStore_Unknown_Property" xml:space="preserve">
    <value>类型“{0}”不包含名为“{1}”的公共属性。</value>
  </data>
  <data name="MaxLengthAttribute_ValidationError" xml:space="preserve">
    <value>字段 {0} 必须是最大长度为“{1}”的字符串或数组类型。</value>
  </data>
  <data name="Validator_Property_Value_Wrong_Type" xml:space="preserve">
    <value>属性“{0}”的值类型必须是“{1}”。</value>
  </data>
  <data name="CustomValidationAttribute_Method_Not_Found" xml:space="preserve">
    <value>CustomValidationAttribute 方法“{0}”不在类型“{1}”中，或者该方法不是公共和静态的。</value>
  </data>
  <data name="PhoneAttribute_Invalid" xml:space="preserve">
    <value>{0} 字段不是有效的电话号码。</value>
  </data>
  <data name="UrlAttribute_Invalid" xml:space="preserve">
    <value>{0} 字段不是有效的完全限定 http、https 或 ftp URL。</value>
  </data>
  <data name="ValidationAttribute_ValidationError" xml:space="preserve">
    <value>字段 {0} 无效。</value>
  </data>
  <data name="EnumDataTypeAttribute_TypeNeedsToBeAnEnum" xml:space="preserve">
    <value>类型“{0}”需要表示一个枚举类型。</value>
  </data>
  <data name="RangeAttribute_ArbitraryTypeNotIComparable" xml:space="preserve">
    <value>类型 {0} 必须实现 {1}。</value>
  </data>
  <data name="FileExtensionsAttribute_Invalid" xml:space="preserve">
    <value>{0} 字段只接受具有下列扩展名的文件: {1}</value>
  </data>
  <data name="ValidationAttribute_NeedBothResourceTypeAndResourceName" xml:space="preserve">
    <value>ErrorMessageResourceType 和 ErrorMessageResourceName 都需要针对此特性进行设置。</value>
  </data>
  <data name="Validator_InstanceMustMatchValidationContextInstance" xml:space="preserve">
    <value>提供的实例必须与所提供的 ValidationContext 的 ObjectInstance 匹配。</value>
  </data>
  <data name="MinLengthAttribute_ValidationError" xml:space="preserve">
    <value>字段 {0} 必须是最小长度为“{1}”的字符串或数组类型。</value>
  </data>
  <data name="MetadataTypeAttribute_TypeCannotBeNull" xml:space="preserve">
    <value>MetadataClassType 不能为 null。</value>
  </data>
  <data name="CustomValidationAttribute_ValidatorType_Required" xml:space="preserve">
    <value>未指定 CustomValidationAttribute.ValidatorType。</value>
  </data>
  <data name="RangeAttribute_Must_Set_Min_And_Max" xml:space="preserve">
    <value>必须设置最小值和最大值。</value>
  </data>
  <data name="ValidationAttribute_ResourceTypeDoesNotHaveProperty" xml:space="preserve">
    <value>资源类型“{0}”没有名为“{1}”的可访问的静态属性。</value>
  </data>
  <data name="MaxLengthAttribute_InvalidMaxLength" xml:space="preserve">
    <value>MaxLengthAttribute 必须包含一个大于零的 Length 值。使用不包含参数的 MaxLength()，以指示字符串或数组可具有最大允许长度。</value>
  </data>
  <data name="Common_PropertyNotFound" xml:space="preserve">
    <value>找不到属性 {0}.{1}。</value>
  </data>
  <data name="CustomValidationAttribute_ValidationError" xml:space="preserve">
    <value>{0} 无效。</value>
  </data>
  <data name="Common_NullOrEmpty" xml:space="preserve">
    <value>值不能为 null 或为空。</value>
  </data>
  <data name="StringLengthAttribute_InvalidMaxLength" xml:space="preserve">
    <value>最大长度必须是非负整数。</value>
  </data>
  <data name="RegexAttribute_ValidationError" xml:space="preserve">
    <value>字段 {0} 必须与正则表达式“{1}”匹配。</value>
  </data>
  <data name="EnumDataTypeAttribute_TypeCannotBeNull" xml:space="preserve">
    <value>为 EnumDataTypeAttribute 提供的类型不能为 null。</value>
  </data>
  <data name="RangeAttribute_Must_Set_Operand_Type" xml:space="preserve">
    <value>当对最小值和最大值使用字符串时，必须设置 OperandType。</value>
  </data>
  <data name="ValidationAttribute_ResourcePropertyNotStringType" xml:space="preserve">
    <value>资源类型“{1}”的属性“{0}”不是字符串类型。</value>
  </data>
  <data name="RequiredAttribute_ValidationError" xml:space="preserve">
    <value>{0} 字段是必需的。</value>
  </data>
  <data name="CompareAttribute_MustMatch" xml:space="preserve">
    <value>“{0}”和“{1}”不匹配。</value>
  </data>
  <data name="EmailAddressAttribute_Invalid" xml:space="preserve">
    <value>{0} 字段不是有效的电子邮件地址。</value>
  </data>
  <data name="AssociatedMetadataTypeTypeDescriptor_MetadataTypeContainsUnknownProperties" xml:space="preserve">
    <value>类型“{0}”的关联元数据类型包含以下未知属性或字段: {1}。请确保这些成员的名称与主类型上的属性的名称匹配。</value>
  </data>
  <data name="CustomValidationAttribute_Method_Must_Return_ValidationResult" xml:space="preserve">
    <value>类型“{1}”中的 CustomValidationAttribute 方法“{0}”必须返回 System.ComponentModel.DataAnnotations.ValidationResult。使用 System.ComponentModel.DataAnnotations.ValidationResult.Success 表示成功。</value>
  </data>
  <data name="UIHintImplementation_ControlParameterKeyOccursMoreThanOnce" xml:space="preserve">
    <value>位于位置 {0} 且具有值“{1}”的密钥参数出现了多次。</value>
  </data>
  <data name="UIHintImplementation_NeedEvenNumberOfControlParameters" xml:space="preserve">
    <value>控件参数的数目必须为偶数。</value>
  </data>
  <data name="CustomValidationAttribute_Method_Signature" xml:space="preserve">
    <value>类型“{1}”中的 CustomValidationAttribute 方法“{0}”必须与预期的签名匹配: public static ValidationResult {0}(object value, ValidationContext context)。值可以是强类型的。ValidationContext 参数是可选的。</value>
  </data>
  <data name="MinLengthAttribute_InvalidMinLength" xml:space="preserve">
    <value>MinLengthAttribute 必须包含大于或等于零的 Length 值。</value>
  </data>
  <data name="DataTypeAttribute_EmptyDataTypeString" xml:space="preserve">
    <value>自定义 DataType 字符串不能为 null 或空。</value>
  </data>
  <data name="ValidationAttribute_Cannot_Set_ErrorMessage_And_Resource" xml:space="preserve">
    <value>必须设置 ErrorMessageString 或 ErrorMessageResourceName，但不能同时设置二者。</value>
  </data>
  <data name="AttributeStore_Type_Must_Be_Public" xml:space="preserve">
    <value>类型“{0}”必须是公共的。</value>
  </data>
  <data name="UIHintImplementation_ControlParameterKeyIsNull" xml:space="preserve">
    <value>位于位置 {0} 的密钥参数为 null。每个密钥控件参数都必须是字符串。</value>
  </data>
  <data name="DisplayAttribute_PropertyNotSet" xml:space="preserve">
    <value>尚未设置 {0} 属性。使用 {1} 方法获取值。</value>
  </data>
  <data name="ValidationAttribute_IsValid_NotImplemented" xml:space="preserve">
    <value>此类尚未实现 IsValid(object value)。首选入口点是 GetValidationResult()，并且类应重写 IsValid(object value, ValidationContext context)。</value>
  </data>
</root>